{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"development/build-from-source/","text":"Building from source \u00b6 This document describes how to build HStreamDB from source code. Building with cabal \u00b6 TODO Building with stack \u00b6 TODO","title":"Building from source"},{"location":"development/build-from-source/#building-from-source","text":"This document describes how to build HStreamDB from source code.","title":"Building from source"},{"location":"development/build-from-source/#building-with-cabal","text":"TODO","title":"Building with cabal"},{"location":"development/build-from-source/#building-with-stack","text":"TODO","title":"Building with stack"},{"location":"development/haskell-style/","text":"Haskell Style Guide \u00b6 This document is a slightly modified version of style guide used in Kowainik . Style guide goals \u00b6 The purpose of this document is to help developers and people working on Haskell code-bases to have a smoother experience while dealing with code in different situations. This style guide aims to increase productivity by defining the following goals: Make code easier to understand: ideas for solutions should not be hidden behind complex and obscure code. Make code easier to read: code arrangement should be immediately apparent after looking at the existing code. Names of functions & variables should be transparent and obvious. Make code easier to write: developers should think about code formatting rules as little as possible. The style guide should answer any query pertaining to the formatting of a specific piece of code. Make code easier to maintain: this style guide aims to reduce the burden of maintaining packages using version control systems unless this conflicts with the previous points. Rule of thumb when working with existing source code The general rule is to stick to the same coding style that is already used in the file you are editing. If you must make significant style modifications, then commit them independently from the functional changes so that someone looking back through the changelog can easily distinguish between them. Indentation \u00b6 Indent code blocks with 2 spaces . Always put a where keyword on a new line. showSign :: Int -> String showSign n | n == 0 = \"Zero\" | n < 0 = \"Negative\" | otherwise = \"Positive\" greet :: IO () greet = do putStrLn \"What is your name?\" name <- getLine putStrLn $ greeting name where greeting :: String -> String greeting name = \"Hey \" ++ name ++ \"!\" Line length \u00b6 The maximum preferred line length is 80 characters . Tip There is no hard rules when it comes to line length. Some lines just have to be a bit longer than usual. However, if your line of code exceeds this limit, try to split code into smaller chunks or break long lines over multiple shorter ones as much as you can. Whitespaces \u00b6 No trailing whitespaces (use some tools to automatically cleanup trailing whitespaces). Surround binary operators with a single space on either side. Alignment \u00b6 Use comma-leading style for formatting module exports, lists, tuples, records, etc. answers :: [ Maybe Int ] answers = [ Just 42 , Just 7 , Nothing ] If a function definition doesn't fit the line limit then align multiple lines according to the same separator like :: , => , -> . -- + Good printQuestion :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () -- + Acceptable if function name is short fun :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () Align records with every field on a separate line with leading commas. -- + Good data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) -- + Acceptable data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) Align sum types with every constructor on its own line with leading = and | . -- + Good data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) -- + Acceptable data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) Try to follow the above rule inside function definitions but without fanatism: -- + Good createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo -- there's no need to put the constructor on a separate line and have an extra line <$> veryLongBar <*> veryLongBaz Basically, it is often possible to join consequent lines without introducing alignment dependency. Try not to span multiple short lines unnecessarily. If a function application must spawn multiple lines to fit within the maximum line length, then write one argument on each line following the head, indented by one level: veryLongProductionName firstArgumentOfThisFunction secondArgumentOfThisFunction ( DummyDatatype withDummyField1 andDummyField2 ) lastArgumentOfThisFunction Naming \u00b6 Functions and variables \u00b6 lowerCamelCase for function and variable names. UpperCamelCase for data types, typeclasses and constructors. Variant Use ids_with_underscores for local variables only. Try not to create new operators. -- What does this 'mouse operator' mean? :thinking_suicide: ( ~@@^> ) :: Functor f => ( a -> b ) -> ( a -> c -> d ) -> ( b -> f c ) -> a -> f d Do not use ultra-short or indescriptive names like a , par , g unless the types of these variables are general enough. -- + Good mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect test ifTrue ifFalse = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if test x then ifTrue x : go xs else ifFalse x : go xs -- - Bad mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect p f g = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if p x then f x : go xs else g x : go xs Do not introduce unnecessarily long names for variables. -- + Good map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map f ( x : xs ) = f x : map f xs -- - Bad map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map function ( firstElement : remainingList ) = function firstElement : map function remainingList For readability reasons, do not capitalize all letters when using an abbreviation as a part of a longer name. For example, write TomlException instead of TOMLException . Unicode symbols are allowed only in modules that already use unicode symbols. If you create a unicode name, you should also create a non-unicode one as an alias. Data types \u00b6 Creating data types is extremely easy in Haskell. It is usually a good idea to introduce a custom data type (enum or newtype ) instead of using a commonly used data type (like Int , String , Set Text , etc.). type aliases are allowed only for specializing general types: -- + Good data StateT s m a type State s = StateT s Identity -- - Bad type Size = Int Use the data type name as the constructor name for data with single constructor and newtype . data User = User Int String The field name for a newtype must be prefixed by un followed by the type name. newtype Size = Size { unSize :: Int } newtype App a = App { unApp :: ReaderT Context IO a } Field names for the record data type should start with the full name of the data type. -- + Good data HealthReading = HealthReading { healthReadingDate :: UTCTime , healthReadingMeasurement :: Double } It is acceptable to use an abbreviation as the field prefix if the data type name is too long. -- + Acceptable data HealthReading = HealthReading { hrDate :: UTCTime , hrMeasurement :: Double } Comments \u00b6 Separate end-of-line comments from the code with 2 spaces . newtype Measure = Measure { unMeasure :: Double -- ^ See how 2 spaces separate this comment } Write Haddock documentation for the top-level functions, function arguments and data type fields. The documentation should give enough information to apply the function without looking at its definition. -- | Single-line short comment. foo :: Int -> [ a ] -> [ a ] -- | Example of multi-line block comment which is very long -- and doesn't fit single line. foo :: Int -> [ a ] -> [ a ] -- + Good -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list -> a -- ^ Element to populate list -> [ a ] -- - Bad -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list {- | Element to populate list -} -> a -> [ a ] If possible, include typeclass laws and function usage examples into the documentation. -- | The class of semigroups (types with an associative binary operation). -- -- Instances should satisfy the associativity law: -- -- * @x '<>' (y '<>' z) = (x '<>' y) '<>' z@ class Semigroup a where ( <> ) :: a -> a -> a -- | The 'intersperse' function takes a character and places it -- between the characters of a 'Text'. -- -- >>> T.intersperse '.' \"SHIELD\" -- \"S.H.I.E.L.D\" intersperse :: Char -> Text -> Text Guideline for module formatting \u00b6 Allowed tools for automatic module formatting: stylish-haskell : for formatting the import section and for alignment. LANGUAGE \u00b6 Put OPTIONS_GHC pragma before LANGUAGE pragmas in a separate section. Write each LANGUAGE pragma on its own line, sort them alphabetically and align by max width among them. {-# OPTIONS_GHC -fno-warn-orphans #-} {-# LANGUAGE ApplicativeDo #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TypeApplications #-} Always put language extensions in the relevant source file. Tip Language extensions must be listed at the very top of the file, above the module name. Export lists \u00b6 Use the following rules to format the export section: Always write an explicit export list. Indent the export list by 2 spaces . You can split the export list into sections. Use Haddock to assign names to these sections. Classes, data types and type aliases should be written before functions in each section. module Map ( -- * Data type Map , Key , empty -- * Update , insert , insertWith , alter ) where Imports \u00b6 Always use explicit import lists or qualified imports. Use qualified imports only if the import list is big enough or there are conflicts in names. This makes the code more robust against changes in dependent libraries. Exception: modules that only reexport other entire modules. Imports should be grouped in the following order: Imports from Hackage packages. Imports from the current project. Put a blank line between each group of imports. The imports in each group should be sorted alphabetically by module name. module MyProject.Foo ( Foo ( .. ) ) where import Control.Exception ( catch , try ) import qualified Data.Aeson as Json import qualified Data.Text as Text import Data.Traversable ( for ) import MyProject.Ansi ( errorMessage , infoMessage ) import qualified MyProject.BigModule as Big data Foo ... Data declaration \u00b6 Refer to the Alignment section to see how to format data type declarations. Records for data types with multiple constructors are forbidden. -- - Bad data Foo = Bar { bar1 :: Int , bar2 :: Double } | Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Good data Foo = FooBar Bar | FooBaz Baz data Bar = Bar { bar1 :: Int , bar2 :: Double } data Baz = Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Also good data Foo = Bar Int Double | Baz Int Double Text Strictness \u00b6 Fields of data type constructors should be strict. Specify strictness explicitly with ! . This helps to avoid space leaks and gives you an error instead of a warning in case you forget to initialize some fields. -- + Good data Settings = Settings { settingsHasTravis :: ! Bool , settingsConfigPath :: ! FilePath , settingsRetryCount :: ! Int } -- - Bad data Settings = Settings { settingsHasTravis :: Bool , settingsConfigPath :: FilePath , settingsRetryCount :: Int } Deriving \u00b6 Type classes in the deriving section should always be surrounded by parentheses. Don't derive typeclasses unnecessarily. Use -XDerivingStrategies extension for newtype s to explicitly specify the way you want to derive type classes: {-# LANGUAGE DeriveAnyClass #-} {-# LANGUAGE DerivingStrategies #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Id a = Id { unId :: Int } deriving stock ( Generic ) deriving newtype ( Eq , Ord , Show , Hashable ) deriving anyclass ( FromJSON , ToJSON ) Function declaration \u00b6 All top-level functions must have type signatures. All functions inside a where block must have type signatures. Explicit type signatures help to avoid cryptic type errors. You might need the -XScopedTypeVariables extension to write the polymorphic types of functions inside a where block. Surround . after forall in type signatures with spaces. lookup :: forall a f . Typeable a => TypeRepMap f -> Maybe ( f a ) If the function type signature is very long, then place the type of each argument under its own line with respect to alignment. sendEmail :: forall env m . ( MonadLog m , MonadEmail m , WithDb env m ) => Email -> Subject -> Body -> Template -> m () If the line with argument names is too big, then put each argument on its own line and separate it somehow from the body section. sendEmail toEmail subject @ ( Subject subj ) body Template { .. } -- default body variables = do < code goes here > In other cases, place an = sign on the same line where the function definition is. Put operator fixity before operator signature: -- | Flipped version of '<$>'. infixl 1 <&> ( <&> ) :: Functor f => f a -> ( a -> b ) -> f b as <&> f = f <$> as Put pragmas immediately following the function they apply to. -- | Lifted version of 'T.putStrLn'. putTextLn :: MonadIO m => Text -> m () putTextLn = liftIO . Text . putStrLn {-# INLINE putTextLn #-} {-# SPECIALIZE putTextLn :: Text -> IO () #-} In case of data type definitions, you must put the pragma before the type it applies to. Example: data TypeRepMap ( f :: k -> Type ) = TypeRepMap { fingerprintAs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , fingerprintBs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , trAnys :: {-# UNPACK #-} ! ( Array Any ) , trKeys :: {-# UNPACK #-} ! ( Array Any ) } if-then-else clauses \u00b6 Prefer guards over if-then-else where possible. -- + Good showParity :: Int -> Bool showParity n | even n = \"even\" | otherwise = \"odd\" -- - Meh showParity :: Int -> Bool showParity n = if even n then \"even\" else \"odd\" In the code outside do -blocks you can align if-then-else clauses like you would normal expressions: shiftInts :: [ Int ] -> [ Int ] shiftInts = map $ \\ n -> if even n then n + 1 else n - 1 Case expressions \u00b6 Align the -> arrows in the alternatives when it helps readability. -- + Good firstOrDefault :: [ a ] -> a -> a firstOrDefault list def = case list of [] -> def x : _ -> x -- - Bad foo :: IO () foo = getArgs >>= \\ case [] -> do putStrLn \"No arguments provided\" runWithNoArgs firstArg : secondArg : rest -> do putStrLn $ \"The first argument is \" ++ firstArg putStrLn $ \"The second argument is \" ++ secondArg _ -> pure () Use the -XLambdaCase extension when you perform pattern matching over the last argument of the function: fromMaybe :: a -> Maybe a -> a fromMaybe v = \\ case Nothing -> v Just x -> x let expressions \u00b6 Write every let -binding on a new line: isLimitedBy :: Integer -> Natural -> Bool isLimitedBy n limit = let intLimit = toInteger limit in n <= intLimit Put a let before each variable inside a do block. General recommendations \u00b6 Try to split code into separate modules. Avoid abusing point-free style. Sometimes code is clearer when not written in point-free style: -- + Good foo :: Int -> a -> Int foo n x = length $ replicate n x -- - Bad foo :: Int -> a -> Int foo = ( length . ) . replicate Code should be compilable with the following ghc options without warnings: -Wall -Wincomplete-uni-patterns -Wincomplete-record-updates -Wcompat -Widentities -Wredundant-constraints -Wmissing-export-lists -Wpartial-fields Enable -fhide-source-paths and -freverse-errors for cleaner compiler output. Use -XApplicativeDo in combination with -XRecordWildCards to prevent position-sensitive errors where possible.","title":"Haskell style"},{"location":"development/haskell-style/#haskell-style-guide","text":"This document is a slightly modified version of style guide used in Kowainik .","title":"Haskell Style Guide"},{"location":"development/haskell-style/#style-guide-goals","text":"The purpose of this document is to help developers and people working on Haskell code-bases to have a smoother experience while dealing with code in different situations. This style guide aims to increase productivity by defining the following goals: Make code easier to understand: ideas for solutions should not be hidden behind complex and obscure code. Make code easier to read: code arrangement should be immediately apparent after looking at the existing code. Names of functions & variables should be transparent and obvious. Make code easier to write: developers should think about code formatting rules as little as possible. The style guide should answer any query pertaining to the formatting of a specific piece of code. Make code easier to maintain: this style guide aims to reduce the burden of maintaining packages using version control systems unless this conflicts with the previous points. Rule of thumb when working with existing source code The general rule is to stick to the same coding style that is already used in the file you are editing. If you must make significant style modifications, then commit them independently from the functional changes so that someone looking back through the changelog can easily distinguish between them.","title":"Style guide goals"},{"location":"development/haskell-style/#indentation","text":"Indent code blocks with 2 spaces . Always put a where keyword on a new line. showSign :: Int -> String showSign n | n == 0 = \"Zero\" | n < 0 = \"Negative\" | otherwise = \"Positive\" greet :: IO () greet = do putStrLn \"What is your name?\" name <- getLine putStrLn $ greeting name where greeting :: String -> String greeting name = \"Hey \" ++ name ++ \"!\"","title":"Indentation"},{"location":"development/haskell-style/#line-length","text":"The maximum preferred line length is 80 characters . Tip There is no hard rules when it comes to line length. Some lines just have to be a bit longer than usual. However, if your line of code exceeds this limit, try to split code into smaller chunks or break long lines over multiple shorter ones as much as you can.","title":"Line length"},{"location":"development/haskell-style/#whitespaces","text":"No trailing whitespaces (use some tools to automatically cleanup trailing whitespaces). Surround binary operators with a single space on either side.","title":"Whitespaces"},{"location":"development/haskell-style/#alignment","text":"Use comma-leading style for formatting module exports, lists, tuples, records, etc. answers :: [ Maybe Int ] answers = [ Just 42 , Just 7 , Nothing ] If a function definition doesn't fit the line limit then align multiple lines according to the same separator like :: , => , -> . -- + Good printQuestion :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () -- + Acceptable if function name is short fun :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () Align records with every field on a separate line with leading commas. -- + Good data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) -- + Acceptable data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) Align sum types with every constructor on its own line with leading = and | . -- + Good data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) -- + Acceptable data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) Try to follow the above rule inside function definitions but without fanatism: -- + Good createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo -- there's no need to put the constructor on a separate line and have an extra line <$> veryLongBar <*> veryLongBaz Basically, it is often possible to join consequent lines without introducing alignment dependency. Try not to span multiple short lines unnecessarily. If a function application must spawn multiple lines to fit within the maximum line length, then write one argument on each line following the head, indented by one level: veryLongProductionName firstArgumentOfThisFunction secondArgumentOfThisFunction ( DummyDatatype withDummyField1 andDummyField2 ) lastArgumentOfThisFunction","title":"Alignment"},{"location":"development/haskell-style/#naming","text":"","title":"Naming"},{"location":"development/haskell-style/#functions-and-variables","text":"lowerCamelCase for function and variable names. UpperCamelCase for data types, typeclasses and constructors. Variant Use ids_with_underscores for local variables only. Try not to create new operators. -- What does this 'mouse operator' mean? :thinking_suicide: ( ~@@^> ) :: Functor f => ( a -> b ) -> ( a -> c -> d ) -> ( b -> f c ) -> a -> f d Do not use ultra-short or indescriptive names like a , par , g unless the types of these variables are general enough. -- + Good mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect test ifTrue ifFalse = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if test x then ifTrue x : go xs else ifFalse x : go xs -- - Bad mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect p f g = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if p x then f x : go xs else g x : go xs Do not introduce unnecessarily long names for variables. -- + Good map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map f ( x : xs ) = f x : map f xs -- - Bad map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map function ( firstElement : remainingList ) = function firstElement : map function remainingList For readability reasons, do not capitalize all letters when using an abbreviation as a part of a longer name. For example, write TomlException instead of TOMLException . Unicode symbols are allowed only in modules that already use unicode symbols. If you create a unicode name, you should also create a non-unicode one as an alias.","title":"Functions and variables"},{"location":"development/haskell-style/#data-types","text":"Creating data types is extremely easy in Haskell. It is usually a good idea to introduce a custom data type (enum or newtype ) instead of using a commonly used data type (like Int , String , Set Text , etc.). type aliases are allowed only for specializing general types: -- + Good data StateT s m a type State s = StateT s Identity -- - Bad type Size = Int Use the data type name as the constructor name for data with single constructor and newtype . data User = User Int String The field name for a newtype must be prefixed by un followed by the type name. newtype Size = Size { unSize :: Int } newtype App a = App { unApp :: ReaderT Context IO a } Field names for the record data type should start with the full name of the data type. -- + Good data HealthReading = HealthReading { healthReadingDate :: UTCTime , healthReadingMeasurement :: Double } It is acceptable to use an abbreviation as the field prefix if the data type name is too long. -- + Acceptable data HealthReading = HealthReading { hrDate :: UTCTime , hrMeasurement :: Double }","title":"Data types"},{"location":"development/haskell-style/#comments","text":"Separate end-of-line comments from the code with 2 spaces . newtype Measure = Measure { unMeasure :: Double -- ^ See how 2 spaces separate this comment } Write Haddock documentation for the top-level functions, function arguments and data type fields. The documentation should give enough information to apply the function without looking at its definition. -- | Single-line short comment. foo :: Int -> [ a ] -> [ a ] -- | Example of multi-line block comment which is very long -- and doesn't fit single line. foo :: Int -> [ a ] -> [ a ] -- + Good -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list -> a -- ^ Element to populate list -> [ a ] -- - Bad -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list {- | Element to populate list -} -> a -> [ a ] If possible, include typeclass laws and function usage examples into the documentation. -- | The class of semigroups (types with an associative binary operation). -- -- Instances should satisfy the associativity law: -- -- * @x '<>' (y '<>' z) = (x '<>' y) '<>' z@ class Semigroup a where ( <> ) :: a -> a -> a -- | The 'intersperse' function takes a character and places it -- between the characters of a 'Text'. -- -- >>> T.intersperse '.' \"SHIELD\" -- \"S.H.I.E.L.D\" intersperse :: Char -> Text -> Text","title":"Comments"},{"location":"development/haskell-style/#guideline-for-module-formatting","text":"Allowed tools for automatic module formatting: stylish-haskell : for formatting the import section and for alignment.","title":"Guideline for module formatting"},{"location":"development/haskell-style/#language","text":"Put OPTIONS_GHC pragma before LANGUAGE pragmas in a separate section. Write each LANGUAGE pragma on its own line, sort them alphabetically and align by max width among them. {-# OPTIONS_GHC -fno-warn-orphans #-} {-# LANGUAGE ApplicativeDo #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TypeApplications #-} Always put language extensions in the relevant source file. Tip Language extensions must be listed at the very top of the file, above the module name.","title":"LANGUAGE"},{"location":"development/haskell-style/#export-lists","text":"Use the following rules to format the export section: Always write an explicit export list. Indent the export list by 2 spaces . You can split the export list into sections. Use Haddock to assign names to these sections. Classes, data types and type aliases should be written before functions in each section. module Map ( -- * Data type Map , Key , empty -- * Update , insert , insertWith , alter ) where","title":"Export lists"},{"location":"development/haskell-style/#imports","text":"Always use explicit import lists or qualified imports. Use qualified imports only if the import list is big enough or there are conflicts in names. This makes the code more robust against changes in dependent libraries. Exception: modules that only reexport other entire modules. Imports should be grouped in the following order: Imports from Hackage packages. Imports from the current project. Put a blank line between each group of imports. The imports in each group should be sorted alphabetically by module name. module MyProject.Foo ( Foo ( .. ) ) where import Control.Exception ( catch , try ) import qualified Data.Aeson as Json import qualified Data.Text as Text import Data.Traversable ( for ) import MyProject.Ansi ( errorMessage , infoMessage ) import qualified MyProject.BigModule as Big data Foo ...","title":"Imports"},{"location":"development/haskell-style/#data-declaration","text":"Refer to the Alignment section to see how to format data type declarations. Records for data types with multiple constructors are forbidden. -- - Bad data Foo = Bar { bar1 :: Int , bar2 :: Double } | Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Good data Foo = FooBar Bar | FooBaz Baz data Bar = Bar { bar1 :: Int , bar2 :: Double } data Baz = Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Also good data Foo = Bar Int Double | Baz Int Double Text","title":"Data declaration"},{"location":"development/haskell-style/#strictness","text":"Fields of data type constructors should be strict. Specify strictness explicitly with ! . This helps to avoid space leaks and gives you an error instead of a warning in case you forget to initialize some fields. -- + Good data Settings = Settings { settingsHasTravis :: ! Bool , settingsConfigPath :: ! FilePath , settingsRetryCount :: ! Int } -- - Bad data Settings = Settings { settingsHasTravis :: Bool , settingsConfigPath :: FilePath , settingsRetryCount :: Int }","title":"Strictness"},{"location":"development/haskell-style/#deriving","text":"Type classes in the deriving section should always be surrounded by parentheses. Don't derive typeclasses unnecessarily. Use -XDerivingStrategies extension for newtype s to explicitly specify the way you want to derive type classes: {-# LANGUAGE DeriveAnyClass #-} {-# LANGUAGE DerivingStrategies #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Id a = Id { unId :: Int } deriving stock ( Generic ) deriving newtype ( Eq , Ord , Show , Hashable ) deriving anyclass ( FromJSON , ToJSON )","title":"Deriving"},{"location":"development/haskell-style/#function-declaration","text":"All top-level functions must have type signatures. All functions inside a where block must have type signatures. Explicit type signatures help to avoid cryptic type errors. You might need the -XScopedTypeVariables extension to write the polymorphic types of functions inside a where block. Surround . after forall in type signatures with spaces. lookup :: forall a f . Typeable a => TypeRepMap f -> Maybe ( f a ) If the function type signature is very long, then place the type of each argument under its own line with respect to alignment. sendEmail :: forall env m . ( MonadLog m , MonadEmail m , WithDb env m ) => Email -> Subject -> Body -> Template -> m () If the line with argument names is too big, then put each argument on its own line and separate it somehow from the body section. sendEmail toEmail subject @ ( Subject subj ) body Template { .. } -- default body variables = do < code goes here > In other cases, place an = sign on the same line where the function definition is. Put operator fixity before operator signature: -- | Flipped version of '<$>'. infixl 1 <&> ( <&> ) :: Functor f => f a -> ( a -> b ) -> f b as <&> f = f <$> as Put pragmas immediately following the function they apply to. -- | Lifted version of 'T.putStrLn'. putTextLn :: MonadIO m => Text -> m () putTextLn = liftIO . Text . putStrLn {-# INLINE putTextLn #-} {-# SPECIALIZE putTextLn :: Text -> IO () #-} In case of data type definitions, you must put the pragma before the type it applies to. Example: data TypeRepMap ( f :: k -> Type ) = TypeRepMap { fingerprintAs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , fingerprintBs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , trAnys :: {-# UNPACK #-} ! ( Array Any ) , trKeys :: {-# UNPACK #-} ! ( Array Any ) }","title":"Function declaration"},{"location":"development/haskell-style/#if-then-else-clauses","text":"Prefer guards over if-then-else where possible. -- + Good showParity :: Int -> Bool showParity n | even n = \"even\" | otherwise = \"odd\" -- - Meh showParity :: Int -> Bool showParity n = if even n then \"even\" else \"odd\" In the code outside do -blocks you can align if-then-else clauses like you would normal expressions: shiftInts :: [ Int ] -> [ Int ] shiftInts = map $ \\ n -> if even n then n + 1 else n - 1","title":"if-then-else clauses"},{"location":"development/haskell-style/#case-expressions","text":"Align the -> arrows in the alternatives when it helps readability. -- + Good firstOrDefault :: [ a ] -> a -> a firstOrDefault list def = case list of [] -> def x : _ -> x -- - Bad foo :: IO () foo = getArgs >>= \\ case [] -> do putStrLn \"No arguments provided\" runWithNoArgs firstArg : secondArg : rest -> do putStrLn $ \"The first argument is \" ++ firstArg putStrLn $ \"The second argument is \" ++ secondArg _ -> pure () Use the -XLambdaCase extension when you perform pattern matching over the last argument of the function: fromMaybe :: a -> Maybe a -> a fromMaybe v = \\ case Nothing -> v Just x -> x","title":"Case expressions"},{"location":"development/haskell-style/#let-expressions","text":"Write every let -binding on a new line: isLimitedBy :: Integer -> Natural -> Bool isLimitedBy n limit = let intLimit = toInteger limit in n <= intLimit Put a let before each variable inside a do block.","title":"let expressions"},{"location":"development/haskell-style/#general-recommendations","text":"Try to split code into separate modules. Avoid abusing point-free style. Sometimes code is clearer when not written in point-free style: -- + Good foo :: Int -> a -> Int foo n x = length $ replicate n x -- - Bad foo :: Int -> a -> Int foo = ( length . ) . replicate Code should be compilable with the following ghc options without warnings: -Wall -Wincomplete-uni-patterns -Wincomplete-record-updates -Wcompat -Widentities -Wredundant-constraints -Wmissing-export-lists -Wpartial-fields Enable -fhide-source-paths and -freverse-errors for cleaner compiler output. Use -XApplicativeDo in combination with -XRecordWildCards to prevent position-sensitive errors where possible.","title":"General recommendations"},{"location":"reference/sql-quick-reference/","text":"Streaming SQL quick reference \u00b6 CREATE STREAM \u00b6 Registers a stream on the bottom layer topic with the same name as the stream. An exception will be thrown if the stream is already created. CREATE STREAM < stream_name > [ AS < select_query > ] WITH ( FORMAT = < stream_format > ); <stream_name> is a valid identifier. <select_query> is an optional SELECT query. For more information, see SELECT section. If <select_query> is specified, the created stream will be filled with records from the SELECT query continuously. Otherwise, only the stream will be created and kept empty. <stream_format> specifies the format of records in the stream. Note that we only support \"JSON\" format now. Examples: CREATE STREAM weather WITH ( FORMAT = \"JSON\" ); CREATE STREAM abnormal_weather AS SELECT * FROM weather WHERE temperature > 30 AND humidity > 80 WITH ( FORMAT = \"JSON\" ); SELECT \u00b6 Continuously pulls records from the stream(s) specified. It is usually used in an interactive CLI to monitor realtime changes of data. Note that the query writes records to a random-named stream. SELECT < select_statement > FROM < from_statement > WHERE < search_condition > GROUP BY < group_by_statement > ; < select_statement > :: = * | < select_substatement > [, ...] < select_substatement > :: = < expression > [ AS < field_alias > ] < from_statement > :: = < stream_name_1 > [ < join_type > JOIN < stream_name_2 > WITHIN ( < interval > ) ON < stream_name_1 > . < field_1 > = < stream_name_2 > . < field_2 > ] < join_type > :: = INNER < where_condition > :: = [ NOT ] < predicate > [( AND | OR ) < predicate > , ...] < predicate > :: = < expression > < comp_op > < expression > < comp_op > :: = = | <> | > | < | >= | <= < group_by_statement > :: = < field_name > | < field_name > , < window_type > < window_type > :: = TUMBLING < interval > | HOPPING < interval > < interval > | SESSION < interval > <expression> can be a field name, a constant or their association, such as temperature , weather.humidity , 114514 , 1 + 2 and SUM(productions) . Formal specification of <expression> is to be added. <interval> represents a period of time: INTERVAL n (SECOND|MINUTE|DAY|WEEK|MONTH|YEAR|) Examples: A simple query: SELECT * FROM my_stream ; Filtering rows: SELECT temperature , humidity FROM weather WHERE temperature > 10 AND humidity < 75 ; Joining streams: SELECT stream1 . temperature , stream2 . humidity FROM stream1 INNER JOIN stream2 WITHIN ( INTERVAL 5 SECOND ) ON stream1 . humidity = stream2 . humidity ; Grouping records: SELECT COUNT ( * ) FROM weather GROUP BY cityId , TUMBLING ( INTERVAL 10 SECOND ); INSERT \u00b6 Insert a record into specified stream. INSERT INTO < stream_name > ( < field_name > , ...) VALUES ( < field_value > , ...); Example: INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 11254469 , 12 , 65 );","title":"Streaming SQL quick reference"},{"location":"reference/sql-quick-reference/#streaming-sql-quick-reference","text":"","title":"Streaming SQL quick reference"},{"location":"reference/sql-quick-reference/#create-stream","text":"Registers a stream on the bottom layer topic with the same name as the stream. An exception will be thrown if the stream is already created. CREATE STREAM < stream_name > [ AS < select_query > ] WITH ( FORMAT = < stream_format > ); <stream_name> is a valid identifier. <select_query> is an optional SELECT query. For more information, see SELECT section. If <select_query> is specified, the created stream will be filled with records from the SELECT query continuously. Otherwise, only the stream will be created and kept empty. <stream_format> specifies the format of records in the stream. Note that we only support \"JSON\" format now. Examples: CREATE STREAM weather WITH ( FORMAT = \"JSON\" ); CREATE STREAM abnormal_weather AS SELECT * FROM weather WHERE temperature > 30 AND humidity > 80 WITH ( FORMAT = \"JSON\" );","title":"CREATE STREAM"},{"location":"reference/sql-quick-reference/#select","text":"Continuously pulls records from the stream(s) specified. It is usually used in an interactive CLI to monitor realtime changes of data. Note that the query writes records to a random-named stream. SELECT < select_statement > FROM < from_statement > WHERE < search_condition > GROUP BY < group_by_statement > ; < select_statement > :: = * | < select_substatement > [, ...] < select_substatement > :: = < expression > [ AS < field_alias > ] < from_statement > :: = < stream_name_1 > [ < join_type > JOIN < stream_name_2 > WITHIN ( < interval > ) ON < stream_name_1 > . < field_1 > = < stream_name_2 > . < field_2 > ] < join_type > :: = INNER < where_condition > :: = [ NOT ] < predicate > [( AND | OR ) < predicate > , ...] < predicate > :: = < expression > < comp_op > < expression > < comp_op > :: = = | <> | > | < | >= | <= < group_by_statement > :: = < field_name > | < field_name > , < window_type > < window_type > :: = TUMBLING < interval > | HOPPING < interval > < interval > | SESSION < interval > <expression> can be a field name, a constant or their association, such as temperature , weather.humidity , 114514 , 1 + 2 and SUM(productions) . Formal specification of <expression> is to be added. <interval> represents a period of time: INTERVAL n (SECOND|MINUTE|DAY|WEEK|MONTH|YEAR|) Examples: A simple query: SELECT * FROM my_stream ; Filtering rows: SELECT temperature , humidity FROM weather WHERE temperature > 10 AND humidity < 75 ; Joining streams: SELECT stream1 . temperature , stream2 . humidity FROM stream1 INNER JOIN stream2 WITHIN ( INTERVAL 5 SECOND ) ON stream1 . humidity = stream2 . humidity ; Grouping records: SELECT COUNT ( * ) FROM weather GROUP BY cityId , TUMBLING ( INTERVAL 10 SECOND );","title":"SELECT"},{"location":"reference/sql-quick-reference/#insert","text":"Insert a record into specified stream. INSERT INTO < stream_name > ( < field_name > , ...) VALUES ( < field_value > , ...); Example: INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 11254469 , 12 , 65 );","title":"INSERT"},{"location":"start/quickstart-with-docker/","text":"Quickstart with Docker \u00b6 Installation \u00b6 Install docker \u00b6 Note If you have already installed docker, you can skip this step. See Install Docker Engine , and install it for your operating system. Please carefully check that you meet all prerequisites. Confirm that the Docker daemon is running: docker version Tips On Linux, Docker needs root privileges. You can also run Docker as a non-root user, see Post-installation steps for Linux . Pull docker images \u00b6 docker pull hstreamdb/logdevice docker pull hstreamdb/hstream Start a local standalone HStream-Server in Docker \u00b6 Warning Do NOT use this configuration in your production environment! Create a directory for storing db datas \u00b6 mkdir ./dbdata Start local logdevice cluster \u00b6 docker run -td --rm --name some-hstream-store -v dbdata:/data/store --network host hstreamdb/logdevice ld-dev-cluster --root /data/store --use-tcp Start HStreamDB Server \u00b6 docker run -it --rm --name some-hstream-server -v dbdata:/data/store --network host hstreamdb/hstream hstream-server --port 6570 -l /data/store/logdevice.conf Start HStreamDB's interactive SQL CLI \u00b6 docker run -it --rm --name some-hstream-cli -v dbdata:/data/store --network host hstreamdb/hstream hstream-client --port 6570 If everything works fine, you will enter an interactive CLI and see help information like Start HStream-Cli! Command :h help command :q quit cli show queries list all queries delete query <taskid> delete query by id delete query all delete all queries <sql> run sql > Create a stream \u00b6 What we are going to do first is create a stream by CREATE STREAM query. The FORMAT parameter after WITH specifies the format of data in the stream. Note that only \"JSON\" format is supported now. CREATE STREAM weather WITH ( FORMAT = \"JSON\" ); Copy and paste this query into the interactive CLI session, and press enter to execute the statement. If everything works fine, you will get something like Right ( CreateTopic { taskid = 0 , tasksql = \"CREATE STREAM weather WITH (FORMAT = \" JSON \");\" , taskTopic = \"weather\" , taskState = Finished , createTime = 2021 - 02 - 04 09 : 07 : 25.639197201 UTC } ) which means the query is successfully executed. Run a continuous query over the stream \u00b6 Now we can run a continuous query over the stream we just created by SELECT query. The query will output all records from the weather stream whose humidity is above 70 percent. SELECT * FROM weather WHERE humidity > 70 ; It seems that nothing happened. But do not worry because there is no data in the stream now. Next, we will fill the stream with some data so the query can produce output we want. Start another CLI session \u00b6 Start another CLI session, this CLI will be used for inserting data into the stream. docker exec -it some-hstream-cli hstream-client --port 6570 Insert data into the stream \u00b6 Run each of the given INSERT query in the new CLI session and keep an eye on the CLI session created in (2). INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 1 , 22 , 80 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 2 , 15 , 20 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 3 , 31 , 76 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 4 , 5 , 45 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 5 , 27 , 82 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 6 , 28 , 86 ); If everything works fine, the continuous query will output matching records in real time.","title":"Quickstart with Docker"},{"location":"start/quickstart-with-docker/#quickstart-with-docker","text":"","title":"Quickstart with Docker"},{"location":"start/quickstart-with-docker/#installation","text":"","title":"Installation"},{"location":"start/quickstart-with-docker/#install-docker","text":"Note If you have already installed docker, you can skip this step. See Install Docker Engine , and install it for your operating system. Please carefully check that you meet all prerequisites. Confirm that the Docker daemon is running: docker version Tips On Linux, Docker needs root privileges. You can also run Docker as a non-root user, see Post-installation steps for Linux .","title":"Install docker"},{"location":"start/quickstart-with-docker/#pull-docker-images","text":"docker pull hstreamdb/logdevice docker pull hstreamdb/hstream","title":"Pull docker images"},{"location":"start/quickstart-with-docker/#start-a-local-standalone-hstream-server-in-docker","text":"Warning Do NOT use this configuration in your production environment!","title":"Start a local standalone HStream-Server in Docker"},{"location":"start/quickstart-with-docker/#create-a-directory-for-storing-db-datas","text":"mkdir ./dbdata","title":"Create a directory for storing db datas"},{"location":"start/quickstart-with-docker/#start-local-logdevice-cluster","text":"docker run -td --rm --name some-hstream-store -v dbdata:/data/store --network host hstreamdb/logdevice ld-dev-cluster --root /data/store --use-tcp","title":"Start local logdevice cluster"},{"location":"start/quickstart-with-docker/#start-hstreamdb-server","text":"docker run -it --rm --name some-hstream-server -v dbdata:/data/store --network host hstreamdb/hstream hstream-server --port 6570 -l /data/store/logdevice.conf","title":"Start HStreamDB Server"},{"location":"start/quickstart-with-docker/#start-hstreamdbs-interactive-sql-cli","text":"docker run -it --rm --name some-hstream-cli -v dbdata:/data/store --network host hstreamdb/hstream hstream-client --port 6570 If everything works fine, you will enter an interactive CLI and see help information like Start HStream-Cli! Command :h help command :q quit cli show queries list all queries delete query <taskid> delete query by id delete query all delete all queries <sql> run sql >","title":"Start HStreamDB's interactive SQL CLI"},{"location":"start/quickstart-with-docker/#create-a-stream","text":"What we are going to do first is create a stream by CREATE STREAM query. The FORMAT parameter after WITH specifies the format of data in the stream. Note that only \"JSON\" format is supported now. CREATE STREAM weather WITH ( FORMAT = \"JSON\" ); Copy and paste this query into the interactive CLI session, and press enter to execute the statement. If everything works fine, you will get something like Right ( CreateTopic { taskid = 0 , tasksql = \"CREATE STREAM weather WITH (FORMAT = \" JSON \");\" , taskTopic = \"weather\" , taskState = Finished , createTime = 2021 - 02 - 04 09 : 07 : 25.639197201 UTC } ) which means the query is successfully executed.","title":"Create a stream"},{"location":"start/quickstart-with-docker/#run-a-continuous-query-over-the-stream","text":"Now we can run a continuous query over the stream we just created by SELECT query. The query will output all records from the weather stream whose humidity is above 70 percent. SELECT * FROM weather WHERE humidity > 70 ; It seems that nothing happened. But do not worry because there is no data in the stream now. Next, we will fill the stream with some data so the query can produce output we want.","title":"Run a continuous query over the stream"},{"location":"start/quickstart-with-docker/#start-another-cli-session","text":"Start another CLI session, this CLI will be used for inserting data into the stream. docker exec -it some-hstream-cli hstream-client --port 6570","title":"Start another CLI session"},{"location":"start/quickstart-with-docker/#insert-data-into-the-stream","text":"Run each of the given INSERT query in the new CLI session and keep an eye on the CLI session created in (2). INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 1 , 22 , 80 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 2 , 15 , 20 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 3 , 31 , 76 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 4 , 5 , 45 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 5 , 27 , 82 ); INSERT INTO weather ( cityId , temperature , humidity ) VALUES ( 6 , 28 , 86 ); If everything works fine, the continuous query will output matching records in real time.","title":"Insert data into the stream"}]}